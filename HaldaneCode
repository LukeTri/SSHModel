import numpy as np
import math
import cmath
import matplotlib.pyplot as plt

def Hamiltonian(N = 30, v = 1.0,w = 1.0,show = False,u=1.0):
    
    eig = np.zeros((N,N))
    matr = np.zeros((N,N),dtype = 'complex')
    for kx in range(1,N+1):
        for ky in range(1,N+1):
            H = -v*cmath.exp(-1j*((2*math.pi)/N)*(ky))-w*cmath.exp(-1j*((2*math.pi)/N)*(-kx*(math.sqrt(3)/2)-ky/2))-u*cmath.exp(-1j*((2*math.pi)/N)*(kx*(math.sqrt(3)/2)-ky/2))
            eig[kx-1][ky-1] = cmath.polar(H)[0]
            matr[kx-1][ky-1] = H
            
                                                                                                                                
    if show:
        eig[0][0] = 0
        plt.imshow(eig,cmap='hot',interpolation='nearest')
        plt.show()
        
    
    return matr
            
            
    
Hamiltonian(100,1,1,True,1)


def Berry(N,v,w,u):
    matr = Hamiltonian(N,v,w,True,u)
    pos = np.zeros((N,N,2))
    
    dat = np.zeros((N,N,2*N*N),dtype = 'complex')
    
    for kx in range(1,N+1):
        for ky in range(1,N+1):
            
            vec = np.array([1,matr[kx-1][ky-1]/cmath.polar(matr[kx-1][ky-1])[0]])
            
            for n in range(0,N):
                for m in range(0,N):
                    
                    dat[kx-1][ky-1][(2*n)*N+2*m] = cmath.exp(((2*math.pi)/N)*(kx*n+ky*m))*vec[0]
                    dat[kx-1][ky-1][(2*n)*N+2*m+1] = cmath.exp(((2*math.pi)/N)*(kx*n+ky*m))*vec[1]
            dat[kx-1][ky-1] = dat[kx-1][ky-1]/np.linalg.norm(dat[kx-1][ky-1])
    sumterm = 0
    for n in range(0,N):
        for m in range(0,N):
        
            sumterm = sumterm-cmath.polar(np.vdot(dat[n][m],dat[(n+1)% N][m])*np.vdot(dat[(n+1)% N][m],dat[(n+1)% N][(m+1)% N])*np.vdot(dat[(n+1)% N][(m+1)% N],dat[n][(m+1)%N])*np.vdot(dat[n][(m+1)%N],dat[n][m]))[1]
    print(sumterm/(2*math.pi))
Berry(25,1,3,1)
