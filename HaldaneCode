import numpy as np
import math
import cmath
import matplotlib.pyplot as plt

def Hamiltonian(N = 30, v = 1.0,w = 1.0,show = False,u=1.0,t=1.0):
    
    eig = np.zeros((N,N))
    matr = np.zeros((N,N,2,2),dtype = 'complex')
    for kx in range(1,N+1):
        for ky in range(1,N+1):
            H = -v*cmath.exp(-1j*((2*math.pi)/N)*(ky))-w*cmath.exp(-1j*((2*math.pi)/N)*(-kx*(math.sqrt(3)/2)-ky/2))-u*cmath.exp(-1j*((2*math.pi)/N)*(kx*(math.sqrt(3)/2)-ky/2))
            z = -2*t*(math.sin((2*math.pi)/N*math.sqrt(3)*kx)+math.sin((2*math.pi)/N*(-kx*(math.sqrt(3)/2)-ky*3/2))+math.sin((2*math.pi)/N*(-kx*(math.sqrt(3)/2)+ky*3/2)))
            matr[kx-1][ky-1] = np.array([[z,H],[np.conj(H),-z]])
            eig[kx-1][ky-1] = cmath.polar(np.linalg.eig(matr[kx-1][ky-1])[0][0]-np.linalg.eig(matr[kx-1][ky-1])[0][1])[0]
            
                                                                                                                                
    if show:
        eig[0][0] = 0
        plt.imshow(eig,cmap='hot',interpolation='nearest')
        plt.colorbar()
        plt.show()
        
    
    return matr
            
            
    
out = Hamiltonian(100,2,5,True,1,10.0)


def Berry(N,v,w,u,t):
    matr = Hamiltonian(N,v,w,True,u,t)
    pos = np.zeros((N,N,2))
    
    dat = np.zeros((N,N,2*N*N),dtype = 'complex')
    
    for kx in range(1,N+1):
        for ky in range(1,N+1):
            
            vec = np.linalg.eigh(matr[kx-1][ky-1])[1][:,np.argmax(np.linalg.eigh(matr[kx-1][ky-1])[0])]
            #vec = vec/vec[0]
            #vec = vec*np.exp(1j*(1.6))
            #vec = np.array([1,matr[kx-1][ky-1][0][1]/cmath.polar(matr[kx-1][ky-1][0][1])[0]])
            
            for n in range(0,N):
                for m in range(0,N):
                    dat[kx-1][ky-1][(2*n)*N+2*m] = np.exp(((2j*math.pi)/N)*(kx*(n*math.sqrt(3))+ky*(n*math.sqrt(3)/2+3/2*m)))*vec[0]
                    dat[kx-1][ky-1][(2*n)*N+2*m+1] = np.exp(((2j*math.pi)/N)*(kx*(n*math.sqrt(3))+ky*(n*math.sqrt(3)/2+3/2*m)))*vec[1]
            dat[kx-1][ky-1] = dat[kx-1][ky-1]

    sumterm = 0
    fail = 0
    for n in range(0,N):
        for m in range(0,N):
            vec1 = dat[n][m]
            vec2 = dat[(n+1)%N][m]
            vec3 = dat[(n+1)%N][(m+1)%N]
            vec4 = dat[n][(m+1)%N]
            
            
            dot1 = cmath.polar(np.vdot(vec1,vec2))[0]
            dot2 = cmath.polar(np.vdot(vec2,vec3))[0]
            dot3 = cmath.polar(np.vdot(vec3,vec4))[0]
            dot4 = cmath.polar(np.vdot(vec4,vec1))[0]
            
            thing = cmath.polar(np.vdot(vec1,vec2)*np.vdot(vec2,vec3)*np.vdot(vec3,vec4)*np.vdot(vec4,vec1))
            #print(dot2)
            #print(np.linalg.eigh(matr[(n+1)%N][m])[0][0],"*",np.linalg.eigh(matr[(n+1)%N][(m+1)%N])[0][0])
            
            
            
            if(thing[0] > 1e-14):
                sumterm = sumterm-thing[1]
            else:
                fail = fail+1
            
    print("Chern Number of:",sumterm/(2*math.pi),", failed ",fail," times.")
    
    return dat


Berry(10,1,2,7,0)
